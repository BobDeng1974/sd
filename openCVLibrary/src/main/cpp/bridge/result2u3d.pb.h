// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: result2u3d.proto

#ifndef PROTOBUF_INCLUDED_result2u3d_2eproto
#define PROTOBUF_INCLUDED_result2u3d_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_result2u3d_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_result2u3d_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_result2u3d_2eproto();
class Point2f;
class Point2fDefaultTypeInternal;
extern Point2fDefaultTypeInternal _Point2f_default_instance_;
class Point3f;
class Point3fDefaultTypeInternal;
extern Point3fDefaultTypeInternal _Point3f_default_instance_;
class Quaternion;
class QuaternionDefaultTypeInternal;
extern QuaternionDefaultTypeInternal _Quaternion_default_instance_;
class Rect;
class RectDefaultTypeInternal;
extern RectDefaultTypeInternal _Rect_default_instance_;
class Result;
class ResultDefaultTypeInternal;
extern ResultDefaultTypeInternal _Result_default_instance_;
namespace google {
namespace protobuf {
template<> ::Point2f* Arena::CreateMaybeMessage<::Point2f>(Arena*);
template<> ::Point3f* Arena::CreateMaybeMessage<::Point3f>(Arena*);
template<> ::Quaternion* Arena::CreateMaybeMessage<::Quaternion>(Arena*);
template<> ::Rect* Arena::CreateMaybeMessage<::Rect>(Arena*);
template<> ::Result* Arena::CreateMaybeMessage<::Result>(Arena*);
}  // namespace protobuf
}  // namespace google

enum GENDER {
  MALE = 0,
  FEMALE = 1,
  OTHER = 2,
  NA = 3
};
bool GENDER_IsValid(int value);
const GENDER GENDER_MIN = MALE;
const GENDER GENDER_MAX = NA;
const int GENDER_ARRAYSIZE = GENDER_MAX + 1;

const ::google::protobuf::EnumDescriptor* GENDER_descriptor();
inline const ::std::string& GENDER_Name(GENDER value) {
  return ::google::protobuf::internal::NameOfEnum(
    GENDER_descriptor(), value);
}
inline bool GENDER_Parse(
    const ::std::string& name, GENDER* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GENDER>(
    GENDER_descriptor(), name, value);
}
enum DISTRACTION_TYPE {
  LEFT = 0,
  RIGHT = 1,
  UP = 2,
  DOWN = 3,
  NORMAL = 4
};
bool DISTRACTION_TYPE_IsValid(int value);
const DISTRACTION_TYPE DISTRACTION_TYPE_MIN = LEFT;
const DISTRACTION_TYPE DISTRACTION_TYPE_MAX = NORMAL;
const int DISTRACTION_TYPE_ARRAYSIZE = DISTRACTION_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* DISTRACTION_TYPE_descriptor();
inline const ::std::string& DISTRACTION_TYPE_Name(DISTRACTION_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    DISTRACTION_TYPE_descriptor(), value);
}
inline bool DISTRACTION_TYPE_Parse(
    const ::std::string& name, DISTRACTION_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DISTRACTION_TYPE>(
    DISTRACTION_TYPE_descriptor(), name, value);
}
// ===================================================================

class Point3f final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Point3f) */ {
 public:
  Point3f();
  virtual ~Point3f();

  Point3f(const Point3f& from);

  inline Point3f& operator=(const Point3f& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point3f(Point3f&& from) noexcept
    : Point3f() {
    *this = ::std::move(from);
  }

  inline Point3f& operator=(Point3f&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Point3f& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point3f* internal_default_instance() {
    return reinterpret_cast<const Point3f*>(
               &_Point3f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Point3f* other);
  friend void swap(Point3f& a, Point3f& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point3f* New() const final {
    return CreateMaybeMessage<Point3f>(nullptr);
  }

  Point3f* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Point3f>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Point3f& from);
  void MergeFrom(const Point3f& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point3f* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1 [default = 0];
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2 [default = 0];
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // required float z = 3 [default = 0];
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:Point3f)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct ::TableStruct_result2u3d_2eproto;
};
// -------------------------------------------------------------------

class Point2f final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Point2f) */ {
 public:
  Point2f();
  virtual ~Point2f();

  Point2f(const Point2f& from);

  inline Point2f& operator=(const Point2f& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point2f(Point2f&& from) noexcept
    : Point2f() {
    *this = ::std::move(from);
  }

  inline Point2f& operator=(Point2f&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Point2f& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Point2f* internal_default_instance() {
    return reinterpret_cast<const Point2f*>(
               &_Point2f_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Point2f* other);
  friend void swap(Point2f& a, Point2f& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point2f* New() const final {
    return CreateMaybeMessage<Point2f>(nullptr);
  }

  Point2f* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Point2f>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Point2f& from);
  void MergeFrom(const Point2f& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Point2f* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1 [default = 0];
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2 [default = 0];
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:Point2f)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  friend struct ::TableStruct_result2u3d_2eproto;
};
// -------------------------------------------------------------------

class Rect final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rect) */ {
 public:
  Rect();
  virtual ~Rect();

  Rect(const Rect& from);

  inline Rect& operator=(const Rect& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Rect(Rect&& from) noexcept
    : Rect() {
    *this = ::std::move(from);
  }

  inline Rect& operator=(Rect&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Rect& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Rect* internal_default_instance() {
    return reinterpret_cast<const Rect*>(
               &_Rect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Rect* other);
  friend void swap(Rect& a, Rect& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Rect* New() const final {
    return CreateMaybeMessage<Rect>(nullptr);
  }

  Rect* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Rect>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Rect& from);
  void MergeFrom(const Rect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rect* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1 [default = 0];
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // required int32 y = 2 [default = 0];
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // required int32 width = 3 [default = 0];
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // required int32 height = 4 [default = 0];
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Rect)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  friend struct ::TableStruct_result2u3d_2eproto;
};
// -------------------------------------------------------------------

class Quaternion final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Quaternion) */ {
 public:
  Quaternion();
  virtual ~Quaternion();

  Quaternion(const Quaternion& from);

  inline Quaternion& operator=(const Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Quaternion(Quaternion&& from) noexcept
    : Quaternion() {
    *this = ::std::move(from);
  }

  inline Quaternion& operator=(Quaternion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Quaternion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quaternion* internal_default_instance() {
    return reinterpret_cast<const Quaternion*>(
               &_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Quaternion* other);
  friend void swap(Quaternion& a, Quaternion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Quaternion* New() const final {
    return CreateMaybeMessage<Quaternion>(nullptr);
  }

  Quaternion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Quaternion>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Quaternion& from);
  void MergeFrom(const Quaternion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quaternion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // required float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // required float w = 4;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 4;
  float w() const;
  void set_w(float value);

  // @@protoc_insertion_point(class_scope:Quaternion)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  float w_;
  friend struct ::TableStruct_result2u3d_2eproto;
};
// -------------------------------------------------------------------

class Result final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Result) */ {
 public:
  Result();
  virtual ~Result();

  Result(const Result& from);

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Result(Result&& from) noexcept
    : Result() {
    *this = ::std::move(from);
  }

  inline Result& operator=(Result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Result* internal_default_instance() {
    return reinterpret_cast<const Result*>(
               &_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Result* other);
  friend void swap(Result& a, Result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Result* New() const final {
    return CreateMaybeMessage<Result>(nullptr);
  }

  Result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Result& from);
  void MergeFrom(const Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Point2f landmarks = 24;
  int landmarks_size() const;
  void clear_landmarks();
  static const int kLandmarksFieldNumber = 24;
  ::Point2f* mutable_landmarks(int index);
  ::google::protobuf::RepeatedPtrField< ::Point2f >*
      mutable_landmarks();
  const ::Point2f& landmarks(int index) const;
  ::Point2f* add_landmarks();
  const ::google::protobuf::RepeatedPtrField< ::Point2f >&
      landmarks() const;

  // required bytes image = 1;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 1;
  const ::std::string& image() const;
  void set_image(const ::std::string& value);
  #if LANG_CXX11
  void set_image(::std::string&& value);
  #endif
  void set_image(const char* value);
  void set_image(const void* value, size_t size);
  ::std::string* mutable_image();
  ::std::string* release_image();
  void set_allocated_image(::std::string* image);

  // optional string name = 20;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 20;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .Point3f left_eye_direction = 12;
  bool has_left_eye_direction() const;
  void clear_left_eye_direction();
  static const int kLeftEyeDirectionFieldNumber = 12;
  const ::Point3f& left_eye_direction() const;
  ::Point3f* release_left_eye_direction();
  ::Point3f* mutable_left_eye_direction();
  void set_allocated_left_eye_direction(::Point3f* left_eye_direction);

  // optional .Point3f right_eye_direction = 13;
  bool has_right_eye_direction() const;
  void clear_right_eye_direction();
  static const int kRightEyeDirectionFieldNumber = 13;
  const ::Point3f& right_eye_direction() const;
  ::Point3f* release_right_eye_direction();
  ::Point3f* mutable_right_eye_direction();
  void set_allocated_right_eye_direction(::Point3f* right_eye_direction);

  // optional .Rect phone_bbox = 16;
  bool has_phone_bbox() const;
  void clear_phone_bbox();
  static const int kPhoneBboxFieldNumber = 16;
  const ::Rect& phone_bbox() const;
  ::Rect* release_phone_bbox();
  ::Rect* mutable_phone_bbox();
  void set_allocated_phone_bbox(::Rect* phone_bbox);

  // optional .Rect cigarette_bbox = 18;
  bool has_cigarette_bbox() const;
  void clear_cigarette_bbox();
  static const int kCigaretteBboxFieldNumber = 18;
  const ::Rect& cigarette_bbox() const;
  ::Rect* release_cigarette_bbox();
  ::Rect* mutable_cigarette_bbox();
  void set_allocated_cigarette_bbox(::Rect* cigarette_bbox);

  // optional .Rect face_bbox = 22;
  bool has_face_bbox() const;
  void clear_face_bbox();
  static const int kFaceBboxFieldNumber = 22;
  const ::Rect& face_bbox() const;
  ::Rect* release_face_bbox();
  ::Rect* mutable_face_bbox();
  void set_allocated_face_bbox(::Rect* face_bbox);

  // optional .Point3f head_pose = 23;
  bool has_head_pose() const;
  void clear_head_pose();
  static const int kHeadPoseFieldNumber = 23;
  const ::Point3f& head_pose() const;
  ::Point3f* release_head_pose();
  ::Point3f* mutable_head_pose();
  void set_allocated_head_pose(::Point3f* head_pose);

  // optional .Quaternion head_quaternion = 30;
  bool has_head_quaternion() const;
  void clear_head_quaternion();
  static const int kHeadQuaternionFieldNumber = 30;
  const ::Quaternion& head_quaternion() const;
  ::Quaternion* release_head_quaternion();
  ::Quaternion* mutable_head_quaternion();
  void set_allocated_head_quaternion(::Quaternion* head_quaternion);

  // optional .Point3f left_eye_center = 31;
  bool has_left_eye_center() const;
  void clear_left_eye_center();
  static const int kLeftEyeCenterFieldNumber = 31;
  const ::Point3f& left_eye_center() const;
  ::Point3f* release_left_eye_center();
  ::Point3f* mutable_left_eye_center();
  void set_allocated_left_eye_center(::Point3f* left_eye_center);

  // optional .Point3f right_eye_center = 32;
  bool has_right_eye_center() const;
  void clear_right_eye_center();
  static const int kRightEyeCenterFieldNumber = 32;
  const ::Point3f& right_eye_center() const;
  ::Point3f* release_right_eye_center();
  ::Point3f* mutable_right_eye_center();
  void set_allocated_right_eye_center(::Point3f* right_eye_center);

  // optional bool mouth_open = 2 [default = false];
  bool has_mouth_open() const;
  void clear_mouth_open();
  static const int kMouthOpenFieldNumber = 2;
  bool mouth_open() const;
  void set_mouth_open(bool value);

  // optional bool yawn = 3 [default = false];
  bool has_yawn() const;
  void clear_yawn();
  static const int kYawnFieldNumber = 3;
  bool yawn() const;
  void set_yawn(bool value);

  // optional bool have_mouth = 5 [default = false];
  bool has_have_mouth() const;
  void clear_have_mouth();
  static const int kHaveMouthFieldNumber = 5;
  bool have_mouth() const;
  void set_have_mouth(bool value);

  // optional bool left_eye_open = 6;
  bool has_left_eye_open() const;
  void clear_left_eye_open();
  static const int kLeftEyeOpenFieldNumber = 6;
  bool left_eye_open() const;
  void set_left_eye_open(bool value);

  // optional bool right_eye_open = 7;
  bool has_right_eye_open() const;
  void clear_right_eye_open();
  static const int kRightEyeOpenFieldNumber = 7;
  bool right_eye_open() const;
  void set_right_eye_open(bool value);

  // optional bool have_left_eye = 8;
  bool has_have_left_eye() const;
  void clear_have_left_eye();
  static const int kHaveLeftEyeFieldNumber = 8;
  bool have_left_eye() const;
  void set_have_left_eye(bool value);

  // optional bool have_right_eye = 9;
  bool has_have_right_eye() const;
  void clear_have_right_eye();
  static const int kHaveRightEyeFieldNumber = 9;
  bool have_right_eye() const;
  void set_have_right_eye(bool value);

  // optional bool doze = 14;
  bool has_doze() const;
  void clear_doze();
  static const int kDozeFieldNumber = 14;
  bool doze() const;
  void set_doze(bool value);

  // optional float left_eye_open_rate = 10;
  bool has_left_eye_open_rate() const;
  void clear_left_eye_open_rate();
  static const int kLeftEyeOpenRateFieldNumber = 10;
  float left_eye_open_rate() const;
  void set_left_eye_open_rate(float value);

  // optional float right_eye_open_rate = 11;
  bool has_right_eye_open_rate() const;
  void clear_right_eye_open_rate();
  static const int kRightEyeOpenRateFieldNumber = 11;
  float right_eye_open_rate() const;
  void set_right_eye_open_rate(float value);

  // optional bool phone = 15;
  bool has_phone() const;
  void clear_phone();
  static const int kPhoneFieldNumber = 15;
  bool phone() const;
  void set_phone(bool value);

  // optional bool smoking = 17;
  bool has_smoking() const;
  void clear_smoking();
  static const int kSmokingFieldNumber = 17;
  bool smoking() const;
  void set_smoking(bool value);

  // optional bool camera_avaliable = 19;
  bool has_camera_avaliable() const;
  void clear_camera_avaliable();
  static const int kCameraAvaliableFieldNumber = 19;
  bool camera_avaliable() const;
  void set_camera_avaliable(bool value);

  // optional bool have_face = 21;
  bool has_have_face() const;
  void clear_have_face();
  static const int kHaveFaceFieldNumber = 21;
  bool have_face() const;
  void set_have_face(bool value);

  // optional float cpu_utilization = 25;
  bool has_cpu_utilization() const;
  void clear_cpu_utilization();
  static const int kCpuUtilizationFieldNumber = 25;
  float cpu_utilization() const;
  void set_cpu_utilization(float value);

  // optional float mem_occupation = 26;
  bool has_mem_occupation() const;
  void clear_mem_occupation();
  static const int kMemOccupationFieldNumber = 26;
  float mem_occupation() const;
  void set_mem_occupation(float value);

  // optional uint32 age = 27;
  bool has_age() const;
  void clear_age();
  static const int kAgeFieldNumber = 27;
  ::google::protobuf::uint32 age() const;
  void set_age(::google::protobuf::uint32 value);

  // optional uint32 fps = 28;
  bool has_fps() const;
  void clear_fps();
  static const int kFpsFieldNumber = 28;
  ::google::protobuf::uint32 fps() const;
  void set_fps(::google::protobuf::uint32 value);

  // optional .GENDER gender = 29;
  bool has_gender() const;
  void clear_gender();
  static const int kGenderFieldNumber = 29;
  ::GENDER gender() const;
  void set_gender(::GENDER value);

  // optional .DISTRACTION_TYPE distraction = 33;
  bool has_distraction() const;
  void clear_distraction();
  static const int kDistractionFieldNumber = 33;
  ::DISTRACTION_TYPE distraction() const;
  void set_distraction(::DISTRACTION_TYPE value);

  // optional float mouth_open_rate = 4 [default = -1];
  bool has_mouth_open_rate() const;
  void clear_mouth_open_rate();
  static const int kMouthOpenRateFieldNumber = 4;
  float mouth_open_rate() const;
  void set_mouth_open_rate(float value);

  // @@protoc_insertion_point(class_scope:Result)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Point2f > landmarks_;
  ::google::protobuf::internal::ArenaStringPtr image_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::Point3f* left_eye_direction_;
  ::Point3f* right_eye_direction_;
  ::Rect* phone_bbox_;
  ::Rect* cigarette_bbox_;
  ::Rect* face_bbox_;
  ::Point3f* head_pose_;
  ::Quaternion* head_quaternion_;
  ::Point3f* left_eye_center_;
  ::Point3f* right_eye_center_;
  bool mouth_open_;
  bool yawn_;
  bool have_mouth_;
  bool left_eye_open_;
  bool right_eye_open_;
  bool have_left_eye_;
  bool have_right_eye_;
  bool doze_;
  float left_eye_open_rate_;
  float right_eye_open_rate_;
  bool phone_;
  bool smoking_;
  bool camera_avaliable_;
  bool have_face_;
  float cpu_utilization_;
  float mem_occupation_;
  ::google::protobuf::uint32 age_;
  ::google::protobuf::uint32 fps_;
  int gender_;
  int distraction_;
  float mouth_open_rate_;
  friend struct ::TableStruct_result2u3d_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point3f

// required float x = 1 [default = 0];
inline bool Point3f::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point3f::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Point3f::x() const {
  // @@protoc_insertion_point(field_get:Point3f.x)
  return x_;
}
inline void Point3f::set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
  // @@protoc_insertion_point(field_set:Point3f.x)
}

// required float y = 2 [default = 0];
inline bool Point3f::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point3f::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Point3f::y() const {
  // @@protoc_insertion_point(field_get:Point3f.y)
  return y_;
}
inline void Point3f::set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
  // @@protoc_insertion_point(field_set:Point3f.y)
}

// required float z = 3 [default = 0];
inline bool Point3f::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Point3f::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Point3f::z() const {
  // @@protoc_insertion_point(field_get:Point3f.z)
  return z_;
}
inline void Point3f::set_z(float value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
  // @@protoc_insertion_point(field_set:Point3f.z)
}

// -------------------------------------------------------------------

// Point2f

// required float x = 1 [default = 0];
inline bool Point2f::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point2f::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Point2f::x() const {
  // @@protoc_insertion_point(field_get:Point2f.x)
  return x_;
}
inline void Point2f::set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
  // @@protoc_insertion_point(field_set:Point2f.x)
}

// required float y = 2 [default = 0];
inline bool Point2f::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point2f::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Point2f::y() const {
  // @@protoc_insertion_point(field_get:Point2f.y)
  return y_;
}
inline void Point2f::set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
  // @@protoc_insertion_point(field_set:Point2f.y)
}

// -------------------------------------------------------------------

// Rect

// required int32 x = 1 [default = 0];
inline bool Rect::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rect::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int32 Rect::x() const {
  // @@protoc_insertion_point(field_get:Rect.x)
  return x_;
}
inline void Rect::set_x(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
  // @@protoc_insertion_point(field_set:Rect.x)
}

// required int32 y = 2 [default = 0];
inline bool Rect::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rect::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 Rect::y() const {
  // @@protoc_insertion_point(field_get:Rect.y)
  return y_;
}
inline void Rect::set_y(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
  // @@protoc_insertion_point(field_set:Rect.y)
}

// required int32 width = 3 [default = 0];
inline bool Rect::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rect::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int32 Rect::width() const {
  // @@protoc_insertion_point(field_get:Rect.width)
  return width_;
}
inline void Rect::set_width(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  width_ = value;
  // @@protoc_insertion_point(field_set:Rect.width)
}

// required int32 height = 4 [default = 0];
inline bool Rect::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rect::clear_height() {
  height_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::int32 Rect::height() const {
  // @@protoc_insertion_point(field_get:Rect.height)
  return height_;
}
inline void Rect::set_height(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  height_ = value;
  // @@protoc_insertion_point(field_set:Rect.height)
}

// -------------------------------------------------------------------

// Quaternion

// required float x = 1;
inline bool Quaternion::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quaternion::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Quaternion::x() const {
  // @@protoc_insertion_point(field_get:Quaternion.x)
  return x_;
}
inline void Quaternion::set_x(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
  // @@protoc_insertion_point(field_set:Quaternion.x)
}

// required float y = 2;
inline bool Quaternion::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quaternion::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Quaternion::y() const {
  // @@protoc_insertion_point(field_get:Quaternion.y)
  return y_;
}
inline void Quaternion::set_y(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
  // @@protoc_insertion_point(field_set:Quaternion.y)
}

// required float z = 3;
inline bool Quaternion::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Quaternion::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Quaternion::z() const {
  // @@protoc_insertion_point(field_get:Quaternion.z)
  return z_;
}
inline void Quaternion::set_z(float value) {
  _has_bits_[0] |= 0x00000004u;
  z_ = value;
  // @@protoc_insertion_point(field_set:Quaternion.z)
}

// required float w = 4;
inline bool Quaternion::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Quaternion::clear_w() {
  w_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float Quaternion::w() const {
  // @@protoc_insertion_point(field_get:Quaternion.w)
  return w_;
}
inline void Quaternion::set_w(float value) {
  _has_bits_[0] |= 0x00000008u;
  w_ = value;
  // @@protoc_insertion_point(field_set:Quaternion.w)
}

// -------------------------------------------------------------------

// Result

// required bytes image = 1;
inline bool Result::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Result::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Result::image() const {
  // @@protoc_insertion_point(field_get:Result.image)
  return image_.GetNoArena();
}
inline void Result::set_image(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Result.image)
}
#if LANG_CXX11
inline void Result::set_image(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Result.image)
}
#endif
inline void Result::set_image(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Result.image)
}
inline void Result::set_image(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Result.image)
}
inline ::std::string* Result::mutable_image() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:Result.image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Result::release_image() {
  // @@protoc_insertion_point(field_release:Result.image)
  if (!has_image()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return image_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Result::set_allocated_image(::std::string* image) {
  if (image != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:Result.image)
}

// optional bool mouth_open = 2 [default = false];
inline bool Result::has_mouth_open() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Result::clear_mouth_open() {
  mouth_open_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool Result::mouth_open() const {
  // @@protoc_insertion_point(field_get:Result.mouth_open)
  return mouth_open_;
}
inline void Result::set_mouth_open(bool value) {
  _has_bits_[0] |= 0x00000800u;
  mouth_open_ = value;
  // @@protoc_insertion_point(field_set:Result.mouth_open)
}

// optional bool yawn = 3 [default = false];
inline bool Result::has_yawn() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Result::clear_yawn() {
  yawn_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool Result::yawn() const {
  // @@protoc_insertion_point(field_get:Result.yawn)
  return yawn_;
}
inline void Result::set_yawn(bool value) {
  _has_bits_[0] |= 0x00001000u;
  yawn_ = value;
  // @@protoc_insertion_point(field_set:Result.yawn)
}

// optional float mouth_open_rate = 4 [default = -1];
inline bool Result::has_mouth_open_rate() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Result::clear_mouth_open_rate() {
  mouth_open_rate_ = -1;
  _has_bits_[0] &= ~0x80000000u;
}
inline float Result::mouth_open_rate() const {
  // @@protoc_insertion_point(field_get:Result.mouth_open_rate)
  return mouth_open_rate_;
}
inline void Result::set_mouth_open_rate(float value) {
  _has_bits_[0] |= 0x80000000u;
  mouth_open_rate_ = value;
  // @@protoc_insertion_point(field_set:Result.mouth_open_rate)
}

// optional bool have_mouth = 5 [default = false];
inline bool Result::has_have_mouth() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Result::clear_have_mouth() {
  have_mouth_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool Result::have_mouth() const {
  // @@protoc_insertion_point(field_get:Result.have_mouth)
  return have_mouth_;
}
inline void Result::set_have_mouth(bool value) {
  _has_bits_[0] |= 0x00002000u;
  have_mouth_ = value;
  // @@protoc_insertion_point(field_set:Result.have_mouth)
}

// optional bool left_eye_open = 6;
inline bool Result::has_left_eye_open() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Result::clear_left_eye_open() {
  left_eye_open_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool Result::left_eye_open() const {
  // @@protoc_insertion_point(field_get:Result.left_eye_open)
  return left_eye_open_;
}
inline void Result::set_left_eye_open(bool value) {
  _has_bits_[0] |= 0x00004000u;
  left_eye_open_ = value;
  // @@protoc_insertion_point(field_set:Result.left_eye_open)
}

// optional bool right_eye_open = 7;
inline bool Result::has_right_eye_open() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Result::clear_right_eye_open() {
  right_eye_open_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool Result::right_eye_open() const {
  // @@protoc_insertion_point(field_get:Result.right_eye_open)
  return right_eye_open_;
}
inline void Result::set_right_eye_open(bool value) {
  _has_bits_[0] |= 0x00008000u;
  right_eye_open_ = value;
  // @@protoc_insertion_point(field_set:Result.right_eye_open)
}

// optional bool have_left_eye = 8;
inline bool Result::has_have_left_eye() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Result::clear_have_left_eye() {
  have_left_eye_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool Result::have_left_eye() const {
  // @@protoc_insertion_point(field_get:Result.have_left_eye)
  return have_left_eye_;
}
inline void Result::set_have_left_eye(bool value) {
  _has_bits_[0] |= 0x00010000u;
  have_left_eye_ = value;
  // @@protoc_insertion_point(field_set:Result.have_left_eye)
}

// optional bool have_right_eye = 9;
inline bool Result::has_have_right_eye() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Result::clear_have_right_eye() {
  have_right_eye_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool Result::have_right_eye() const {
  // @@protoc_insertion_point(field_get:Result.have_right_eye)
  return have_right_eye_;
}
inline void Result::set_have_right_eye(bool value) {
  _has_bits_[0] |= 0x00020000u;
  have_right_eye_ = value;
  // @@protoc_insertion_point(field_set:Result.have_right_eye)
}

// optional float left_eye_open_rate = 10;
inline bool Result::has_left_eye_open_rate() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Result::clear_left_eye_open_rate() {
  left_eye_open_rate_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline float Result::left_eye_open_rate() const {
  // @@protoc_insertion_point(field_get:Result.left_eye_open_rate)
  return left_eye_open_rate_;
}
inline void Result::set_left_eye_open_rate(float value) {
  _has_bits_[0] |= 0x00080000u;
  left_eye_open_rate_ = value;
  // @@protoc_insertion_point(field_set:Result.left_eye_open_rate)
}

// optional float right_eye_open_rate = 11;
inline bool Result::has_right_eye_open_rate() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Result::clear_right_eye_open_rate() {
  right_eye_open_rate_ = 0;
  _has_bits_[0] &= ~0x00100000u;
}
inline float Result::right_eye_open_rate() const {
  // @@protoc_insertion_point(field_get:Result.right_eye_open_rate)
  return right_eye_open_rate_;
}
inline void Result::set_right_eye_open_rate(float value) {
  _has_bits_[0] |= 0x00100000u;
  right_eye_open_rate_ = value;
  // @@protoc_insertion_point(field_set:Result.right_eye_open_rate)
}

// optional .Point3f left_eye_direction = 12;
inline bool Result::has_left_eye_direction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Result::clear_left_eye_direction() {
  if (left_eye_direction_ != nullptr) left_eye_direction_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::Point3f& Result::left_eye_direction() const {
  const ::Point3f* p = left_eye_direction_;
  // @@protoc_insertion_point(field_get:Result.left_eye_direction)
  return p != nullptr ? *p : *reinterpret_cast<const ::Point3f*>(
      &::_Point3f_default_instance_);
}
inline ::Point3f* Result::release_left_eye_direction() {
  // @@protoc_insertion_point(field_release:Result.left_eye_direction)
  _has_bits_[0] &= ~0x00000004u;
  ::Point3f* temp = left_eye_direction_;
  left_eye_direction_ = nullptr;
  return temp;
}
inline ::Point3f* Result::mutable_left_eye_direction() {
  _has_bits_[0] |= 0x00000004u;
  if (left_eye_direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::Point3f>(GetArenaNoVirtual());
    left_eye_direction_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Result.left_eye_direction)
  return left_eye_direction_;
}
inline void Result::set_allocated_left_eye_direction(::Point3f* left_eye_direction) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete left_eye_direction_;
  }
  if (left_eye_direction) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      left_eye_direction = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left_eye_direction, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  left_eye_direction_ = left_eye_direction;
  // @@protoc_insertion_point(field_set_allocated:Result.left_eye_direction)
}

// optional .Point3f right_eye_direction = 13;
inline bool Result::has_right_eye_direction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Result::clear_right_eye_direction() {
  if (right_eye_direction_ != nullptr) right_eye_direction_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::Point3f& Result::right_eye_direction() const {
  const ::Point3f* p = right_eye_direction_;
  // @@protoc_insertion_point(field_get:Result.right_eye_direction)
  return p != nullptr ? *p : *reinterpret_cast<const ::Point3f*>(
      &::_Point3f_default_instance_);
}
inline ::Point3f* Result::release_right_eye_direction() {
  // @@protoc_insertion_point(field_release:Result.right_eye_direction)
  _has_bits_[0] &= ~0x00000008u;
  ::Point3f* temp = right_eye_direction_;
  right_eye_direction_ = nullptr;
  return temp;
}
inline ::Point3f* Result::mutable_right_eye_direction() {
  _has_bits_[0] |= 0x00000008u;
  if (right_eye_direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::Point3f>(GetArenaNoVirtual());
    right_eye_direction_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Result.right_eye_direction)
  return right_eye_direction_;
}
inline void Result::set_allocated_right_eye_direction(::Point3f* right_eye_direction) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete right_eye_direction_;
  }
  if (right_eye_direction) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      right_eye_direction = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right_eye_direction, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  right_eye_direction_ = right_eye_direction;
  // @@protoc_insertion_point(field_set_allocated:Result.right_eye_direction)
}

// optional bool doze = 14;
inline bool Result::has_doze() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Result::clear_doze() {
  doze_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool Result::doze() const {
  // @@protoc_insertion_point(field_get:Result.doze)
  return doze_;
}
inline void Result::set_doze(bool value) {
  _has_bits_[0] |= 0x00040000u;
  doze_ = value;
  // @@protoc_insertion_point(field_set:Result.doze)
}

// optional bool phone = 15;
inline bool Result::has_phone() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Result::clear_phone() {
  phone_ = false;
  _has_bits_[0] &= ~0x00200000u;
}
inline bool Result::phone() const {
  // @@protoc_insertion_point(field_get:Result.phone)
  return phone_;
}
inline void Result::set_phone(bool value) {
  _has_bits_[0] |= 0x00200000u;
  phone_ = value;
  // @@protoc_insertion_point(field_set:Result.phone)
}

// optional .Rect phone_bbox = 16;
inline bool Result::has_phone_bbox() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Result::clear_phone_bbox() {
  if (phone_bbox_ != nullptr) phone_bbox_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::Rect& Result::phone_bbox() const {
  const ::Rect* p = phone_bbox_;
  // @@protoc_insertion_point(field_get:Result.phone_bbox)
  return p != nullptr ? *p : *reinterpret_cast<const ::Rect*>(
      &::_Rect_default_instance_);
}
inline ::Rect* Result::release_phone_bbox() {
  // @@protoc_insertion_point(field_release:Result.phone_bbox)
  _has_bits_[0] &= ~0x00000010u;
  ::Rect* temp = phone_bbox_;
  phone_bbox_ = nullptr;
  return temp;
}
inline ::Rect* Result::mutable_phone_bbox() {
  _has_bits_[0] |= 0x00000010u;
  if (phone_bbox_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rect>(GetArenaNoVirtual());
    phone_bbox_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Result.phone_bbox)
  return phone_bbox_;
}
inline void Result::set_allocated_phone_bbox(::Rect* phone_bbox) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete phone_bbox_;
  }
  if (phone_bbox) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      phone_bbox = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, phone_bbox, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  phone_bbox_ = phone_bbox;
  // @@protoc_insertion_point(field_set_allocated:Result.phone_bbox)
}

// optional bool smoking = 17;
inline bool Result::has_smoking() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Result::clear_smoking() {
  smoking_ = false;
  _has_bits_[0] &= ~0x00400000u;
}
inline bool Result::smoking() const {
  // @@protoc_insertion_point(field_get:Result.smoking)
  return smoking_;
}
inline void Result::set_smoking(bool value) {
  _has_bits_[0] |= 0x00400000u;
  smoking_ = value;
  // @@protoc_insertion_point(field_set:Result.smoking)
}

// optional .Rect cigarette_bbox = 18;
inline bool Result::has_cigarette_bbox() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Result::clear_cigarette_bbox() {
  if (cigarette_bbox_ != nullptr) cigarette_bbox_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::Rect& Result::cigarette_bbox() const {
  const ::Rect* p = cigarette_bbox_;
  // @@protoc_insertion_point(field_get:Result.cigarette_bbox)
  return p != nullptr ? *p : *reinterpret_cast<const ::Rect*>(
      &::_Rect_default_instance_);
}
inline ::Rect* Result::release_cigarette_bbox() {
  // @@protoc_insertion_point(field_release:Result.cigarette_bbox)
  _has_bits_[0] &= ~0x00000020u;
  ::Rect* temp = cigarette_bbox_;
  cigarette_bbox_ = nullptr;
  return temp;
}
inline ::Rect* Result::mutable_cigarette_bbox() {
  _has_bits_[0] |= 0x00000020u;
  if (cigarette_bbox_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rect>(GetArenaNoVirtual());
    cigarette_bbox_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Result.cigarette_bbox)
  return cigarette_bbox_;
}
inline void Result::set_allocated_cigarette_bbox(::Rect* cigarette_bbox) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cigarette_bbox_;
  }
  if (cigarette_bbox) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cigarette_bbox = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cigarette_bbox, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  cigarette_bbox_ = cigarette_bbox;
  // @@protoc_insertion_point(field_set_allocated:Result.cigarette_bbox)
}

// optional bool camera_avaliable = 19;
inline bool Result::has_camera_avaliable() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Result::clear_camera_avaliable() {
  camera_avaliable_ = false;
  _has_bits_[0] &= ~0x00800000u;
}
inline bool Result::camera_avaliable() const {
  // @@protoc_insertion_point(field_get:Result.camera_avaliable)
  return camera_avaliable_;
}
inline void Result::set_camera_avaliable(bool value) {
  _has_bits_[0] |= 0x00800000u;
  camera_avaliable_ = value;
  // @@protoc_insertion_point(field_set:Result.camera_avaliable)
}

// optional string name = 20;
inline bool Result::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Result::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& Result::name() const {
  // @@protoc_insertion_point(field_get:Result.name)
  return name_.GetNoArena();
}
inline void Result::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Result.name)
}
#if LANG_CXX11
inline void Result::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Result.name)
}
#endif
inline void Result::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Result.name)
}
inline void Result::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Result.name)
}
inline ::std::string* Result::mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:Result.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Result::release_name() {
  // @@protoc_insertion_point(field_release:Result.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Result::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:Result.name)
}

// optional bool have_face = 21;
inline bool Result::has_have_face() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Result::clear_have_face() {
  have_face_ = false;
  _has_bits_[0] &= ~0x01000000u;
}
inline bool Result::have_face() const {
  // @@protoc_insertion_point(field_get:Result.have_face)
  return have_face_;
}
inline void Result::set_have_face(bool value) {
  _has_bits_[0] |= 0x01000000u;
  have_face_ = value;
  // @@protoc_insertion_point(field_set:Result.have_face)
}

// optional .Rect face_bbox = 22;
inline bool Result::has_face_bbox() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Result::clear_face_bbox() {
  if (face_bbox_ != nullptr) face_bbox_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::Rect& Result::face_bbox() const {
  const ::Rect* p = face_bbox_;
  // @@protoc_insertion_point(field_get:Result.face_bbox)
  return p != nullptr ? *p : *reinterpret_cast<const ::Rect*>(
      &::_Rect_default_instance_);
}
inline ::Rect* Result::release_face_bbox() {
  // @@protoc_insertion_point(field_release:Result.face_bbox)
  _has_bits_[0] &= ~0x00000040u;
  ::Rect* temp = face_bbox_;
  face_bbox_ = nullptr;
  return temp;
}
inline ::Rect* Result::mutable_face_bbox() {
  _has_bits_[0] |= 0x00000040u;
  if (face_bbox_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rect>(GetArenaNoVirtual());
    face_bbox_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Result.face_bbox)
  return face_bbox_;
}
inline void Result::set_allocated_face_bbox(::Rect* face_bbox) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete face_bbox_;
  }
  if (face_bbox) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      face_bbox = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, face_bbox, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  face_bbox_ = face_bbox;
  // @@protoc_insertion_point(field_set_allocated:Result.face_bbox)
}

// optional .Point3f head_pose = 23;
inline bool Result::has_head_pose() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Result::clear_head_pose() {
  if (head_pose_ != nullptr) head_pose_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::Point3f& Result::head_pose() const {
  const ::Point3f* p = head_pose_;
  // @@protoc_insertion_point(field_get:Result.head_pose)
  return p != nullptr ? *p : *reinterpret_cast<const ::Point3f*>(
      &::_Point3f_default_instance_);
}
inline ::Point3f* Result::release_head_pose() {
  // @@protoc_insertion_point(field_release:Result.head_pose)
  _has_bits_[0] &= ~0x00000080u;
  ::Point3f* temp = head_pose_;
  head_pose_ = nullptr;
  return temp;
}
inline ::Point3f* Result::mutable_head_pose() {
  _has_bits_[0] |= 0x00000080u;
  if (head_pose_ == nullptr) {
    auto* p = CreateMaybeMessage<::Point3f>(GetArenaNoVirtual());
    head_pose_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Result.head_pose)
  return head_pose_;
}
inline void Result::set_allocated_head_pose(::Point3f* head_pose) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete head_pose_;
  }
  if (head_pose) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      head_pose = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, head_pose, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  head_pose_ = head_pose;
  // @@protoc_insertion_point(field_set_allocated:Result.head_pose)
}

// repeated .Point2f landmarks = 24;
inline int Result::landmarks_size() const {
  return landmarks_.size();
}
inline void Result::clear_landmarks() {
  landmarks_.Clear();
}
inline ::Point2f* Result::mutable_landmarks(int index) {
  // @@protoc_insertion_point(field_mutable:Result.landmarks)
  return landmarks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Point2f >*
Result::mutable_landmarks() {
  // @@protoc_insertion_point(field_mutable_list:Result.landmarks)
  return &landmarks_;
}
inline const ::Point2f& Result::landmarks(int index) const {
  // @@protoc_insertion_point(field_get:Result.landmarks)
  return landmarks_.Get(index);
}
inline ::Point2f* Result::add_landmarks() {
  // @@protoc_insertion_point(field_add:Result.landmarks)
  return landmarks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Point2f >&
Result::landmarks() const {
  // @@protoc_insertion_point(field_list:Result.landmarks)
  return landmarks_;
}

// optional float cpu_utilization = 25;
inline bool Result::has_cpu_utilization() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Result::clear_cpu_utilization() {
  cpu_utilization_ = 0;
  _has_bits_[0] &= ~0x02000000u;
}
inline float Result::cpu_utilization() const {
  // @@protoc_insertion_point(field_get:Result.cpu_utilization)
  return cpu_utilization_;
}
inline void Result::set_cpu_utilization(float value) {
  _has_bits_[0] |= 0x02000000u;
  cpu_utilization_ = value;
  // @@protoc_insertion_point(field_set:Result.cpu_utilization)
}

// optional float mem_occupation = 26;
inline bool Result::has_mem_occupation() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Result::clear_mem_occupation() {
  mem_occupation_ = 0;
  _has_bits_[0] &= ~0x04000000u;
}
inline float Result::mem_occupation() const {
  // @@protoc_insertion_point(field_get:Result.mem_occupation)
  return mem_occupation_;
}
inline void Result::set_mem_occupation(float value) {
  _has_bits_[0] |= 0x04000000u;
  mem_occupation_ = value;
  // @@protoc_insertion_point(field_set:Result.mem_occupation)
}

// optional uint32 age = 27;
inline bool Result::has_age() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Result::clear_age() {
  age_ = 0u;
  _has_bits_[0] &= ~0x08000000u;
}
inline ::google::protobuf::uint32 Result::age() const {
  // @@protoc_insertion_point(field_get:Result.age)
  return age_;
}
inline void Result::set_age(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x08000000u;
  age_ = value;
  // @@protoc_insertion_point(field_set:Result.age)
}

// optional uint32 fps = 28;
inline bool Result::has_fps() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Result::clear_fps() {
  fps_ = 0u;
  _has_bits_[0] &= ~0x10000000u;
}
inline ::google::protobuf::uint32 Result::fps() const {
  // @@protoc_insertion_point(field_get:Result.fps)
  return fps_;
}
inline void Result::set_fps(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x10000000u;
  fps_ = value;
  // @@protoc_insertion_point(field_set:Result.fps)
}

// optional .GENDER gender = 29;
inline bool Result::has_gender() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Result::clear_gender() {
  gender_ = 0;
  _has_bits_[0] &= ~0x20000000u;
}
inline ::GENDER Result::gender() const {
  // @@protoc_insertion_point(field_get:Result.gender)
  return static_cast< ::GENDER >(gender_);
}
inline void Result::set_gender(::GENDER value) {
  assert(::GENDER_IsValid(value));
  _has_bits_[0] |= 0x20000000u;
  gender_ = value;
  // @@protoc_insertion_point(field_set:Result.gender)
}

// optional .Quaternion head_quaternion = 30;
inline bool Result::has_head_quaternion() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Result::clear_head_quaternion() {
  if (head_quaternion_ != nullptr) head_quaternion_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::Quaternion& Result::head_quaternion() const {
  const ::Quaternion* p = head_quaternion_;
  // @@protoc_insertion_point(field_get:Result.head_quaternion)
  return p != nullptr ? *p : *reinterpret_cast<const ::Quaternion*>(
      &::_Quaternion_default_instance_);
}
inline ::Quaternion* Result::release_head_quaternion() {
  // @@protoc_insertion_point(field_release:Result.head_quaternion)
  _has_bits_[0] &= ~0x00000100u;
  ::Quaternion* temp = head_quaternion_;
  head_quaternion_ = nullptr;
  return temp;
}
inline ::Quaternion* Result::mutable_head_quaternion() {
  _has_bits_[0] |= 0x00000100u;
  if (head_quaternion_ == nullptr) {
    auto* p = CreateMaybeMessage<::Quaternion>(GetArenaNoVirtual());
    head_quaternion_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Result.head_quaternion)
  return head_quaternion_;
}
inline void Result::set_allocated_head_quaternion(::Quaternion* head_quaternion) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete head_quaternion_;
  }
  if (head_quaternion) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      head_quaternion = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, head_quaternion, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  head_quaternion_ = head_quaternion;
  // @@protoc_insertion_point(field_set_allocated:Result.head_quaternion)
}

// optional .Point3f left_eye_center = 31;
inline bool Result::has_left_eye_center() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Result::clear_left_eye_center() {
  if (left_eye_center_ != nullptr) left_eye_center_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::Point3f& Result::left_eye_center() const {
  const ::Point3f* p = left_eye_center_;
  // @@protoc_insertion_point(field_get:Result.left_eye_center)
  return p != nullptr ? *p : *reinterpret_cast<const ::Point3f*>(
      &::_Point3f_default_instance_);
}
inline ::Point3f* Result::release_left_eye_center() {
  // @@protoc_insertion_point(field_release:Result.left_eye_center)
  _has_bits_[0] &= ~0x00000200u;
  ::Point3f* temp = left_eye_center_;
  left_eye_center_ = nullptr;
  return temp;
}
inline ::Point3f* Result::mutable_left_eye_center() {
  _has_bits_[0] |= 0x00000200u;
  if (left_eye_center_ == nullptr) {
    auto* p = CreateMaybeMessage<::Point3f>(GetArenaNoVirtual());
    left_eye_center_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Result.left_eye_center)
  return left_eye_center_;
}
inline void Result::set_allocated_left_eye_center(::Point3f* left_eye_center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete left_eye_center_;
  }
  if (left_eye_center) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      left_eye_center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, left_eye_center, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  left_eye_center_ = left_eye_center;
  // @@protoc_insertion_point(field_set_allocated:Result.left_eye_center)
}

// optional .Point3f right_eye_center = 32;
inline bool Result::has_right_eye_center() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Result::clear_right_eye_center() {
  if (right_eye_center_ != nullptr) right_eye_center_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::Point3f& Result::right_eye_center() const {
  const ::Point3f* p = right_eye_center_;
  // @@protoc_insertion_point(field_get:Result.right_eye_center)
  return p != nullptr ? *p : *reinterpret_cast<const ::Point3f*>(
      &::_Point3f_default_instance_);
}
inline ::Point3f* Result::release_right_eye_center() {
  // @@protoc_insertion_point(field_release:Result.right_eye_center)
  _has_bits_[0] &= ~0x00000400u;
  ::Point3f* temp = right_eye_center_;
  right_eye_center_ = nullptr;
  return temp;
}
inline ::Point3f* Result::mutable_right_eye_center() {
  _has_bits_[0] |= 0x00000400u;
  if (right_eye_center_ == nullptr) {
    auto* p = CreateMaybeMessage<::Point3f>(GetArenaNoVirtual());
    right_eye_center_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Result.right_eye_center)
  return right_eye_center_;
}
inline void Result::set_allocated_right_eye_center(::Point3f* right_eye_center) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete right_eye_center_;
  }
  if (right_eye_center) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      right_eye_center = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, right_eye_center, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  right_eye_center_ = right_eye_center;
  // @@protoc_insertion_point(field_set_allocated:Result.right_eye_center)
}

// optional .DISTRACTION_TYPE distraction = 33;
inline bool Result::has_distraction() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Result::clear_distraction() {
  distraction_ = 0;
  _has_bits_[0] &= ~0x40000000u;
}
inline ::DISTRACTION_TYPE Result::distraction() const {
  // @@protoc_insertion_point(field_get:Result.distraction)
  return static_cast< ::DISTRACTION_TYPE >(distraction_);
}
inline void Result::set_distraction(::DISTRACTION_TYPE value) {
  assert(::DISTRACTION_TYPE_IsValid(value));
  _has_bits_[0] |= 0x40000000u;
  distraction_ = value;
  // @@protoc_insertion_point(field_set:Result.distraction)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::GENDER> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::GENDER>() {
  return ::GENDER_descriptor();
}
template <> struct is_proto_enum< ::DISTRACTION_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::DISTRACTION_TYPE>() {
  return ::DISTRACTION_TYPE_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_result2u3d_2eproto
